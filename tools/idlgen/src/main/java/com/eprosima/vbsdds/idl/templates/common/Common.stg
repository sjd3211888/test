// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ------------------------------------------------------------------
// Modification history:
// 2024-10 ~ 2025-05: idlgen optimization: super large heap support, open source content refinement, add fileVBSHeader etc.
// ------------------------------------------------------------------

group Common;

fileHeader(ctx, file, description) ::= <<
// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file $file$
 * $description$
 *
 * This file was generated by the tool $ctx.product$gen.
 */
>>

fileVBSHeader(ctx, file, description) ::= <<
/*
 * Copyright (c) 2025 Li Auto Inc. and its affiliates
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

 /*!
 * @file $file$
 * $description$
 *
 * This file was generated by the tool $ctx.product$gen.
 */
>>

paramRetType(typecode) ::= <<
$if(typecode)$
$typecode.cppTypename$
$else$
void
$endif$
>>

paramTypeByRef(typecode) ::= <<
$typecode.cppTypename$&
>>

paramDeclsByValue(params, separatorInicial) ::= <<
$if(params)$$separatorInicial$$endif$$params : {param |/*$param.comment$*/ $paramTypeByValue(typecode=param.typecode)$ $param.name$}; separator=", "$
>>

paramDeclsByRef(params, separatorInicial) ::= <<
$if(params)$$separatorInicial$$endif$$params : {param |/*$param.comment$*/ $paramTypeByRef(typecode=param.typecode)$ $param.name$}; separator=", "$
>>

paramDeclsOnlyOutByRef(params, separatorInicial) ::= <<
$if(params)$$separatorInicial$$endif$$params : {param | /*$param.comment$*/ $if(param.output)$$paramTypeByRef(typecode=param.typecode)$$else$$paramTypeByValue(typecode=param.typecode)$$endif$ $param.name$}; separator=", "$
>>

extractParams(params, separatorInicial) ::= <<
$if(params)$$separatorInicial$$endif$$params : {param | $param.name$};separator=", "$
>>

/** Extensions **/

keyFunctionHeaders(ctx, type) ::= <<
$if(!ctx.HasMutable)$
/*!
 * @brief This function returns the maximum serialized size of the Key of an object
 * depending on the buffer alignment.
 * @param current_alignment Buffer alignment.
 * @return Maximum serialized size.
 */
vbs_user_DllExport static $big_align(ctx=ctx)$ getKeyMaxCdrSerializedSize(
        $big_align(ctx=ctx)$ current_alignment = 0);
$endif$

/*!
 * @brief This function tells you if the Key has been defined for this type
 */
vbs_user_DllExport static bool isKeyDefined();

/*!
 * @brief This function serializes the key members of an object using CDR serialization.
 * @param cdr CDR serialization object.
 */
vbs_user_DllExport void serializeKey(
    $ecdr_namespace_get(ctx=ctx)$Cdr& cdr) const;
>>

keyFunctionHeadersStruct(ctx, parent, struct) ::= <<
$keyFunctionHeaders(ctx=ctx, type=struct)$
>>

keyFunctionSourcesStruct(ctx, parent, struct) ::= <<
$if(!ctx.HasMutable)$
$big_align(ctx=ctx)$ $if(ctx.RmGlobalNP)$$struct.Scopednamenormal$$else$$struct.scopedname$$endif$::getKeyMaxCdrSerializedSize(
        $big_align(ctx=ctx)$ current_alignment)
{
    $big_align(ctx=ctx)$ current_align = current_alignment;

    $if(struct.inheritances)$    $struct.inheritances : {current_align += $it.scopedname$::getKeyMaxCdrSerializedSize(current_align);}; separator="\n"$ $endif$

    $struct.members : { member | $if(member.annotationKey)$ $max_serialized_size(ctx=ctx, typecode=member.typecode, var="current_align")$ $endif$}; separator="\n"$

    return current_align;
}
$endif$

bool $struct.scopedname$::isKeyDefined()
{
    $if(struct.inheritances)$    $struct.inheritances : {if ($it.scopedname$::isKeyDefined())$\n$        return true;$\n$}; separator="    else\n    "$ $endif$    return $if(struct.hasKey)$true$else$false$endif$;
}

void $struct.scopedname$::serializeKey(
        $ecdr_namespace_get(ctx=ctx)$Cdr& scdr) const
{
    (void) scdr;
    $if(struct.inheritances)$    $struct.inheritances : {$it.scopedname$::serializeKey(scdr);}; separator="\n"$ $endif$
    $struct.members : { member |$if(member.annotationKey)$ $object_serialization_in_types_source(ctx=ctx, member=member)$ $endif$ }; separator=""$
}

>>

fwd_decl(ctx, parent, type) ::= <<
$if(type.ScopednameList)$
$type.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

class $type.name$;

$if(type.ScopednameList)$
$type.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$

>>

boolean_converter ::= [
    "true":"true",
    default:
]

/**** NEW OUR_TYPES ****/
/*UTILS*/
ecdr_namespace_get(ctx) ::= <<$if(ctx.NotUseVbsFramework)$vbsutil::ecdr::$else$vbs::$endif$>>

big_align(ctx) ::= <<$if(ctx.BigAlignment)$int64_t$else$size_t$endif$>>

object_serialization_in_types_source(ctx, member) ::= <<
$if(ctx.HideInternals)$
$object_serialization(ctx=ctx, object=member, preffix="pImpl->m_")$
$else$
$object_serialization(ctx=ctx, object=member, preffix="m_")$
$endif$

>>