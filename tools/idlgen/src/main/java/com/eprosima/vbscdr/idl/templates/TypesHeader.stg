// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ------------------------------------------------------------------
// Modification history:
// 2023-03 ~ 2025-05: Provided IDL & serialization, macro alignment, zero-copy interface, multi-language, compatibility/performance fixes.
// ------------------------------------------------------------------

group TypesHeader;

main(ctx, definitions) ::= <<
$fileHeader(file=[ctx.filename, ".h"], description=["This header file contains the declaration of the described types in the IDL file."])$

#ifndef _EDDS_GENERATED$if(!ctx.NotUseRandom)$_$ctx.RandomNumber$$endif$_$ctx.headerGuardName$_H_
#define _EDDS_GENERATED$if(!ctx.NotUseRandom)$_$ctx.LastRandomNumber$$endif$_$ctx.headerGuardName$_H_

//$if(ctx.printexception)$
//#include <$ctx.product$/exceptions/UserException.h>
//$endif$

$ctx.FileNames : {include | #include "$include$$if(ctx.RtiIdl)$Base$else$$endif$.$if(ctx.GenHpp)$hpp$else$h$endif$"}; separator="\n"$

#include "SafeEnum.$if(ctx.GenHpp)$hpp$else$h$endif$"
$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
// #include "ContainerPrintHelpers.$if(ctx.GenHpp)$hpp$else$h$endif$"
$endif$

$if(ctx.UseStaticCapacity)$#include "StaticCapacityDynamicArray.$if(ctx.GenHpp)$hpp$else$h$endif$"$endif$
$endif$

$if(ctx.PureStructure)$
#include "FixedString.$if(ctx.GenHpp)$hpp$else$h$endif$"

namespace vbs {
template<size_t MAX_CHARS>
using fixed_string = vbsutil::ecdr::fixed_string<MAX_CHARS>;
}

$else$

$if(ctx.NotUseVbsFramework)$
$if(!ctx.HasMutable)$
#include <ertps/utils/fixed_size_string.hpp>
$else$
#include <ecdr/cdr/fixed_size_string.hpp>
#include <ecdr/xcdr/external.hpp>
#include <ecdr/xcdr/optional.hpp>
$endif$

$if(ctx.Rpc)$
#include <erpc/utils/RpcDataType.hpp>
#include <ecdr/cdr/fixed_size_string.hpp>
#include <ecdr/Cdr.h>
$endif$

$else$
$if(ctx.GenBoth)$
#include <vbs/RpcHeader.hpp>
#include <vbs/Global.hpp>
#include <vbs/Topic.hpp>
$else$
$if(ctx.Rpc)$
#include <vbs/RpcHeader.hpp>
$else$
#include <vbs/Global.hpp>
#include <vbs/Topic.hpp>
$endif$
$endif$


$endif$

$endif$

#include <stdint.h>
#include <array>
#include <string>
#include <vector>
#include <map>
#include <bitset>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <cmath>
$if(ctx.HideInternals)$#include <memory>$endif$

$if(ctx.Rpc)$
#include <sstream>
$endif$

#include <type_traits>
#include <set>

#if defined(_WIN32)
#if defined(VBS_USER_DLL_EXPORT)
#define vbs_user_DllExport __declspec( dllexport )
#else
#define vbs_user_DllExport
#endif  // VBS_USER_DLL_EXPORT
#else
#define vbs_user_DllExport
#endif  // _WIN32

#if defined(_WIN32)
#if defined(VBS_USER_DLL_EXPORT)
#if defined($ctx.filename;format="toUpper"$_SOURCE)
#define $ctx.filename;format="toUpper"$_DllAPI __declspec( dllexport )
#else
#define $ctx.filename;format="toUpper"$_DllAPI __declspec( dllimport )
#endif // $ctx.filename;format="toUpper"$_SOURCE
#else
#define $ctx.filename;format="toUpper"$_DllAPI
#endif  // VBS_USER_DLL_EXPORT
#else
#define $ctx.filename;format="toUpper"$_DllAPI
#endif // _WIN32

$if(ctx.NotUseVbsFramework)$
$if(ctx.cdr)$
namespace vbsutil {
namespace ecdr {
class Cdr;
} // namespace ecdr
} // namespace vbsutil

$endif$

$if(ctx.vbscdr)$
namespace vbsutil {
namespace ecdr {
class Cdr;
} // namespace ecdr
} // namespace vbsutil

$endif$
$endif$

$if(ctx.generateTypesC)$
$ctx.typeCodesToDefine : {
$sequences_definition(it.value)$
}; separator="\n"$
$endif$

$if(!ctx.PureStructure)$
namespace vbs
{
$if(ctx.NotUseVbsFramework)$
$else$
#ifndef _VBSTYPE_GEN_TEMP_
#define _VBSTYPE_GEN_TEMP_

template<typename T>
struct isVBSType<T, typename std::enable_if<std::is_member_function_pointer<decltype(&T::VBSVersionPrinter)>::value>::type> : std::true_type {};

#endif // _VBSTYPE_GEN_TEMP_

$if(!ctx.GenBoth)$

#ifndef _VBSTYPE_$if(ctx.Rpc)$RPC$else$DDS$endif$_GEN_TEMP_
#define _VBSTYPE_$if(ctx.Rpc)$RPC$else$DDS$endif$_GEN_TEMP_

template<typename T>
struct isVBS$if(ctx.Rpc)$Rpc$else$Dds$endif$Type<T, typename std::enable_if<std::is_member_function_pointer<decltype(&T::VBS$if(ctx.Rpc)$Rpc$else$Dds$endif$Printer)>::value>::type> : std::true_type {};

#endif // _VBSTYPE_$if(ctx.Rpc)$RPC$else$DDS$endif$_GEN_TEMP_

$endif$

$endif$

}
$endif$

$if(ctx.HideInternals)$
namespace CommonConstants {
    extern const std::uintptr_t INVALID_POINTER_VALUE;
}
$endif$

$if(ctx.GenBoth)$
$ctx.types:{ type | $if(type.inScope)$$if(type.typeCode.IsType_10)$$else$$if(type.typeCode.isStructType)$
constexpr int64_t $type.typeCode.cScopedname$_max_cdr_typesize $left_brackets()$$type.typeCode.maxSerializedSize$ULL$right_brackets()$;
constexpr int64_t $type.typeCode.cScopedname$_max_key_cdr_typesize $left_brackets()$$type.typeCode.maxKeySerializedSize$ULL$right_brackets()$;

constexpr int64_t $type.typeCode.cScopedname$_max_estimate_typesize $left_brackets()$$type.typeCode.EstimateSize$ULL$right_brackets()$;
$endif$$endif$$endif$
}; separator="\n"$
$endif$

$if(!ctx.Rpc)$
$ctx.types:{ type | $if(type.inScope)$$if(type.typeCode.IsType_10)$$else$$if(type.typeCode.isStructType)$
constexpr int64_t $type.typeCode.cScopedname$_max_cdr_typesize $left_brackets()$$type.typeCode.maxSerializedSize$ULL$right_brackets()$;
constexpr int64_t $type.typeCode.cScopedname$_max_key_cdr_typesize $left_brackets()$$type.typeCode.maxKeySerializedSize$ULL$right_brackets()$;

constexpr int64_t $type.typeCode.cScopedname$_max_estimate_typesize $left_brackets()$$type.typeCode.EstimateSize$ULL$right_brackets()$;
$endif$$endif$$endif$
}; separator="\n"$
$endif$

$definitions; separator="\n"$

#endif // _EDDS_GENERATED$if(!ctx.NotUseRandom)$_$ctx.LastRandomNumber$$endif$_$ctx.headerGuardName$_H_
>>

// TODO name -> module
module(ctx, parent, module, definition_list) ::= <<

$definition_list$
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

annotation(ctx, annotation) ::= <<
$if(annotation.ScopednameList)$
$annotation.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

namespace $annotation.name$ {
    $annotation.enums : {$enum_type(ctx=ctx, parent=annotation, enum=it)$}; separator="\n"$

    $annotation.typeDefs : {$typedef_decl(ctx=ctx, parent=annotation, typedefs=it)$}; separator="\n"$

    $annotation.constDecls : {$const_decl(ctx=ctx, parent=annotation, const=it)$}; separator="\n"$

} // namespace $annotation.name$

$if(annotation.ScopednameList)$
$annotation.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$
>>

interface(ctx, parent, interface, export_list) ::= <<
$if(ctx.Rpc)$
$else$
/*!
 * @brief This class represents the interface $interface.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class $ctx.filename;format="toUpper"$_DllAPI $interface.name$ $if(interface.bases)$: $interface.bases : {base |public $base.scopedname$}; separator=", "$$endif$
{
public:

    $export_list$

    std::string to_idl_string(std::set<std::string>* processedTypes = nullptr, const bool is_top = true) const;

$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
    friend vbs_user_DllExport std::ostream& operator<<(std::ostream& o, const $interface.scopedname$& sample);

$endif$
$endif$
};
$endif$
>>

export_list(exports) ::= <<
$exports; separator="\n"$
>>

exception(ctx, parent, exception) ::= <<
$if(exception.ScopednameList)$
$exception.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

$if(ctx.printexception)$
/*!
 * @brief This class implementes the user exception $exception.scopedname$
 * @ingroup $ctx.trimfilename$
 */
class $exception.name$ : public evbs::rpc::exception::UserException
{
public:

    //! @brief Default constructor.
    vbs_user_DllExport $exception.name$();

    /*!
     * @brief Copy constructor.
     * @param ex Exception to be copied.
     */
    vbs_user_DllExport $exception.name$(
            const $exception.name$& ex);

    /*!
     * @brief Move constructor.
     * @param ex Exception to be moved.
     */
    vbs_user_DllExport $exception.name$(
            $exception.name$&& ex);

$if(exception.Empty)$
$else$
     /*!
     * @brief Move constructor.
     * @param ex Exception all params to be copied.
     */
    vbs_user_DllExport $exception.name$(
        $exception.members:{ member |const $member_type_declaration(ctx = ctx, member = member)$& $member.Name$}; separator=",\n"$);
$endif$

    /*!
     * @brief Copy assignment.
     * @param ex Exception to be copied.
     */
    vbs_user_DllExport $exception.name$& operator =(
            const $exception.name$ &ex);

    /*!
     * @brief Move assignment.
     * @param ex Exception to be moved.
     */
    vbs_user_DllExport $exception.name$& operator =(
            $exception.name$&& ex);

    //! @brief Destructor.
    vbs_user_DllExport virtual ~$exception.name$() noexcept override;

    //! @brief This function throws the object as exception.
    vbs_user_DllExport virtual void raise() const;

    $exception.members:{ member |$public_member_declaration(ctx=ctx, member=member, istop=exception.Top)$}; separator="\n"$

$if(!ctx.PureStructure)$
    $size_functions(exception)$

    $serialization_functions(exception)$
$endif$

    std::string to_idl_string(std::set<std::string>* processedTypes = nullptr, const bool is_top = true) const;
$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
    friend vbs_user_DllExport std::ostream& operator<<(std::ostream& o, const $exception.scopedname$& sample);

$endif$
$endif$

$if(!ctx.PureStructure)$
    void VBSVersionPrinter() {
        std::cout << "VBS IDL Gen Version 1.3.0-20240522-001" << std::endl;
    }

$if(!ctx.GenBoth)$
    void VBS$if(ctx.Rpc)$Rpc$else$Dds$endif$Printer() {
        std::cout << "This is $if(ctx.Rpc)$Rpc$else$Dds$endif$ code." << std::endl;
    }
$endif$
$endif$

$if(ctx.TestExample)$
    vbs_user_DllExport void updateTest(int index);
$endif$

private:

    // Exception members
    $exception.members:{ member |$private_member_declaration(ctx=ctx, member=member, istop=exception.Top)$}; separator="\n"$
};

inline void swap($exception.scopedname$& a, $exception.scopedname$& b) {
    a.swap(b);
}

$endif$

$if(exception.ScopednameList)$
$exception.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$
>>

operation(ctx, parent, operation, param_list) ::= <<
$if(operation.ScopednameList)$
$operation.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

$if(ctx.printoperation)$
virtual int32_t $operation.name$(/*in*/ int32_t async_flag$paramDeclarationsRpc(params=operation.inputparam)$, /*in*/ int32_t (*func)(int32_t$if(operation.rettypeparam)$, $paramRetType(operation.rettype)$$endif$$paramDefinitionCallback(params=operation.outputparam)$), /*in*/ int32_t time) = 0;

$endif$

$if(operation.ScopednameList)$
$operation.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$
>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, parent, const) ::= <<

$if(const.ScopednameList)$
$const.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

$if(ctx.inScopedFile)$$if(const.parent)$$if(const.parent.isInterface)$static $endif$$endif$const $const.typeCode.cppTypename$ $const.name$$if(!const.parent)$$if(const.typeCode.IsType_d)$$if(const.IsValueNull)$ = ""$else$ = $const.value$$endif$$else$ = $const.value$$endif$$elseif(!const.parent.isInterface)$$if(const.typeCode.IsType_d)$$if(const.IsValueNull)$ = ""$else$ = $const.value$$endif$$else$ = $const.value$$endif$$elseif(!const.typeCode.isType_5)$$if(!const.typeCode.isType_6)$ = $const.value$$endif$$endif$;$endif$

$if(const.ScopednameList)$
$const.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$
>>

typedef_decl(ctx, parent, typedefs) ::= <<

$if(typedefs.ScopednameList)$
$typedefs.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

$if(ctx.generateTypesC)$
$if(typedefs.typedefContentTypeCode.isSequenceType)$
$sequences_definition_impl(typecode=typedefs.typedefContentTypeCode, typename=typedefs.name)$
$else$
typedef $typedefs.typedefContentTypeCode.cppTypename$ $typedefs.name$;
$endif$
$else$
typedef $typedefs.typedefContentTypeCode.cppTypename$ $typedefs.name$;
$endif$

$if(typedefs.ScopednameList)$
$typedefs.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$

>>

struct_type(ctx, parent, struct, extensions) ::= <<

$if(struct.ScopednameList)$
$struct.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

/*!
 * @brief This class represents the structure $struct.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */

$if(ctx.UseTypeAlias)$
class $struct.name$PubSubType;
$endif$

$if(!ctx.HideInternals)$$if(struct.isPlain)$$if(!ctx.UsePackOne)$
#pragma pack(push, 4)
$endif$$endif$$endif$
class $if(!ctx.HideInternals)$$if(struct.PackOneAndPlain)$__attribute__((packed))$endif$$endif$ $struct.name$$if(struct.InheritancesName)$ : $struct.InheritancesName : {public $it$}; separator=", "$$endif$
{
public:

$if(ctx.UseTypeAlias)$
    typedef $struct.name$PubSubType vbs_pub_sub_type;
$endif$

    /*!
     * @brief Default constructor.
     */
    vbs_user_DllExport $struct.name$();

    /*!
     * @brief Default destructor.
     */
    vbs_user_DllExport ~$struct.name$();

    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    vbs_user_DllExport $struct.name$(
            const $struct.name$& x);

    /*!
     * @brief Move constructor.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    vbs_user_DllExport $struct.name$(
            $struct.name$&& x);

$if(struct.Empty)$
$else$
$if(ctx.ZeroCopy)$
$else$
     /*!
     * @brief Move constructor.
     * @param x All parameters to the object $struct.scopedname$ that will be copied.
     */
     vbs_user_DllExport $struct.name$(
        $struct.members:{ member |const $member_type_declaration(ctx = ctx, member = member)$& $member.Name$}; separator=",\n"$);
$endif$
$endif$

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    vbs_user_DllExport $struct.name$& operator =(
            const $struct.name$& x);

    /*!
     * @brief Move assignment.
     * @param x Reference to the object $struct.scopedname$ that will be copied.
     */
    vbs_user_DllExport $struct.name$& operator =(
            $struct.name$&& x);

    /*!
     * @brief Comparison operator.
     * @param x $struct.scopedname$ object to compare.
     */
    vbs_user_DllExport bool operator ==(
            const $struct.name$& x) const;

    /*!
     * @brief Comparison operator.
     * @param x $struct.scopedname$ object to compare.
     */
    vbs_user_DllExport bool operator !=(
            const $struct.name$& x) const;

    $struct.members:{$public_member_declaration(ctx=ctx,member=it,istop=struct.Top)$}; separator="\n"$

$if(!ctx.PureStructure)$
    $size_functions(struct)$

    $serialization_functions(struct)$

    $extensions : {$it$}; separator="\n"$
$endif$

    void swap($struct.scopedname$& other_);

    std::string to_idl_string(std::set<std::string>* processedTypes = nullptr, const bool is_top = true) const;

    static std::string get_type_name();

$if(ctx.Rpc)$
    void reset_all_member();
$endif$

$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
    friend vbs_user_DllExport std::ostream& operator<<(std::ostream& o, const $struct.scopedname$& sample);

$endif$
$endif$

$if(!ctx.PureStructure)$
    void VBSVersionPrinter() {
        std::cout << "VBS IDL Gen Version 1.3.0-20240522-001" << std::endl;
    }

$if(!ctx.GenBoth)$
    void VBS$if(ctx.Rpc)$Rpc$else$Dds$endif$Printer() {
        std::cout << "This is $if(ctx.Rpc)$Rpc$else$Dds$endif$ code." << std::endl;
    }
$endif$
$endif$

$if(!ctx.PureStructure)$
$if(struct.UseBBMode)$
$if(struct.Top)$
    /*!
     * @brief This function set a big buffer for data.
     * @param pointer to big buffer whiched loaned before.
     */
    vbs_user_DllExport void bigbuffer(void* _bigbuffer);

    /*!
     * @brief This function returns big buffer for data.
     * @return pointer to big buffer.
     */
    vbs_user_DllExport void* bigbuffer();

    /*!
     * @brief This function returns size of the big buffer for data.
     * @return size of the big buffer.
     */
    vbs_user_DllExport uint32_t bigbuffer_size();

$endif$
$endif$
$endif$

$if(ctx.TestExample)$
    vbs_user_DllExport void updateTest(int index);
$endif$

$if(!ctx.PureStructure)$
$if(ctx.HasMutable)$
    void serialize($ecdr_namespace_get(ctx=ctx)$Cdr& scdr) const;

    void deserialize($ecdr_namespace_get(ctx=ctx)$Cdr& scdr);
$endif$

$if(ctx.GenBoth)$
$if(ctx.GenerateTypeObject)$
    static void register_dynamic_type();
$if(ctx.UseVbsFramework)$
    static vbs::VBSDynamicType get_vbs_dynamic_type();
$endif$
$endif$
$endif$

$if(!ctx.Rpc)$
$if(ctx.GenerateTypeObject)$
    static void register_dynamic_type();
$if(ctx.UseVbsFramework)$
    static vbs::VBSDynamicType get_vbs_dynamic_type();
$endif$
$endif$
$endif$
$endif$

$if(ctx.HideInternals)$
    class Impl;
    Impl* get_pImpl() const {
        return pImpl;
    }

    Impl** get_pImpl_addr() {
        return &pImpl;
    }
$endif$

private:
$if(ctx.HideInternals)$
    Impl* pImpl;
$else$
    $struct.members:{$private_member_declaration(ctx=ctx, member=it, istop=struct.Top)$}; separator="\n"$
$if(struct.UseBBMode)$
$if(struct.Top)$
    $struct.BBModeMembers:{member |uint32_t m_$member.name$_size;}; separator="\n"$
    std::vector<uint32_t*> m_big_data_size;
    std::vector<void**> m_big_data_ptr;
    void* m_bigbuffer = nullptr;
$endif$
$endif$
$endif$

};
$if(!ctx.HideInternals)$$if(struct.isPlain)$$if(!ctx.UsePackOne)$
#pragma pack(pop)
$endif$$endif$$endif$

inline void swap($struct.scopedname$& a, $struct.scopedname$& b) {
    a.swap(b);
}

$if(struct.ScopednameList)$
$struct.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$

$if(!ctx.PureStructure)$
$if(!ctx.NotUseVbsFramework)$
namespace vbs {
$if(ctx.Rpc)$
template<>
struct rpc_type_support<$struct.scopedname$> {

static bool ToBuffer(const $struct.scopedname$& sample, std::vector<char>& buffer);

static bool FromBuffer($struct.scopedname$& sample, const std::vector<char>& buffer);
};

$endif$

$if(!ctx.CJ)$
$if(!ctx.RmPrintHelper)$
std::string data_to_json_string(const $struct.scopedname$& sample,
                std::ostringstream* o_ptr = nullptr, const bool is_need_delete = true, const bool include_braces = true);
$endif$
$endif$

}
$endif$
$endif$
>>

union_type(ctx, parent, union, extensions) ::= <<

$if(union.ScopednameList)$
$union.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

/*!
 * @brief This class represents the union $union.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class $union.name$
{
public:

    /*!
     * @brief Default constructor.
     */
    vbs_user_DllExport $union.name$();

    /*!
     * @brief Default destructor.
     */
    vbs_user_DllExport ~$union.name$();

    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    vbs_user_DllExport $union.name$(
            const $union.name$& x);

    /*!
     * @brief Move constructor.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    vbs_user_DllExport $union.name$(
            $union.name$&& x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    vbs_user_DllExport $union.name$& operator =(
            const $union.name$& x);

    /*!
     * @brief Move assignment.
     * @param x Reference to the object $union.scopedname$ that will be copied.
     */
    vbs_user_DllExport $union.name$& operator =(
            $union.name$&& x);

    /*!
     * @brief Comparison operator.
     * @param x $union.scopedname$ object to compare.
     */
    vbs_user_DllExport bool operator ==(
            const $union.name$& x) const;

    /*!
     * @brief Comparison operator.
     * @param x $union.scopedname$ object to compare.
     */
    vbs_user_DllExport bool operator !=(
            const $union.name$& x) const;

    /*!
     * @brief This function sets the discriminator value.
     * @param __d New value for the discriminator.
     * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the new value doesn't correspond to the selected union member.
     */
    vbs_user_DllExport void _d(
            $union.discriminator.cppTypename$ __d);

    /*!
     * @brief This function returns the value of the discriminator.
     * @return Value of the discriminator
     */
    vbs_user_DllExport $union.discriminator.cppTypename$ _d() const;

    /*!
     * @brief This function returns a reference to the discriminator.
     * @return Reference to the discriminator.
     */
    vbs_user_DllExport $union.discriminator.cppTypename$& _d();

    $union.members:{$public_unionmember_declaration(ctx=ctx, member=it, istop=union.Top)$}; separator="\n"$

$if(!ctx.PureStructure)$
    $size_functions(union)$

    $serialization_functions(union)$
$endif$

    $extensions : {$it$}; separator="\n"$

    static $union.discriminator.cppTypename$$if(union.discriminator.NeedsPointer)$*$endif$ default_discriminator();

    void swap($union.scopedname$& other_);

    std::string to_idl_string(std::set<std::string>* processedTypes = nullptr, const bool is_top = true) const;

$if(!ctx.PureStructure)$
$if(ctx.HasMutable)$
    void serialize($ecdr_namespace_get(ctx=ctx)$Cdr& scdr) const;

    void deserialize($ecdr_namespace_get(ctx=ctx)$Cdr& scdr);
$endif$
$endif$

$if(ctx.Rpc)$
    void reset_all_member();
$endif$

$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
    friend vbs_user_DllExport std::ostream& operator<<(std::ostream& o, const $union.scopedname$& sample);

$endif$
$endif$

$if(!ctx.PureStructure)$
    void VBSVersionPrinter() {
        std::cout << "VBS IDL Gen Version 1.3.0-20240522-001" << std::endl;
    }

$if(!ctx.GenBoth)$
    void VBS$if(ctx.Rpc)$Rpc$else$Dds$endif$Printer() {
        std::cout << "This is $if(ctx.Rpc)$Rpc$else$Dds$endif$ code." << std::endl;
    }
$endif$
$endif$

$if(ctx.TestExample)$
    vbs_user_DllExport void updateTest(int index);
$endif$

$if(ctx.HideInternals)$
    class Impl;
    Impl* get_pImpl() const {
        return pImpl;
    }

    Impl** get_pImpl_addr() {
        return &pImpl;
    }
$endif$

private:

$if(ctx.HideInternals)$
    Impl* pImpl;
$else$
    $union.discriminator.cppTypename$ m__d;

    $union.members:{$private_member_declaration(ctx=ctx, member=it, istop=union.Top)$}; separator="\n"$
$endif$

};

inline void swap($union.scopedname$& a, $union.scopedname$& b) {
    a.swap(b);
}

$if(union.ScopednameList)$
$union.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$

$if(union.forwarded)$
$if(!ctx.NotUseVbsFramework)$
namespace vbs {
$if(!ctx.CJ)$
$if(!ctx.RmPrintHelper)$
void data_to_json_string(const $union.scopedname$& sample,
                std::ostringstream* o_ptr = nullptr, const bool is_need_delete = false, const bool include_braces = true);
$endif$
$endif$

}
$endif$
$endif$

>>

bitset_type(ctx, parent, bitset, extensions) ::= <<

$if(bitset.ScopednameList)$
$bitset.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

/*!
 * @brief This class represents the structure $bitset.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
class $bitset.name$$if(bitset.parents)$ : public $bitset.parents : {$public_bitset_inheritances(it)$}; separator=", "$ $endif$
{
public:

    /*!
     * @brief Default constructor.
     */
    vbs_user_DllExport $bitset.name$();

    /*!
     * @brief Default destructor.
     */
    vbs_user_DllExport ~$bitset.name$();

    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    vbs_user_DllExport $bitset.name$(
            const $bitset.name$& x);

    /*!
     * @brief Move constructor.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    vbs_user_DllExport $bitset.name$(
            $bitset.name$&& x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    vbs_user_DllExport $bitset.name$& operator =(
            const $bitset.name$& x);

    /*!
     * @brief Move assignment.
     * @param x Reference to the object $bitset.scopedname$ that will be copied.
     */
    vbs_user_DllExport $bitset.name$& operator =(
            $bitset.name$&& x);

    /*!
     * @brief Comparison operator.
     * @param x $bitset.scopedname$ object to compare.
     */
    vbs_user_DllExport bool operator ==(
            const $bitset.name$& x) const;

    /*!
     * @brief Comparison operator.
     * @param x $bitset.scopedname$ object to compare.
     */
    vbs_user_DllExport bool operator !=(
            const $bitset.name$& x) const;

    $bitset.bitfields:{$public_bitfield_declaration(it)$}; separator="\n"$

$if(!ctx.PureStructure)$
    $size_functions(bitset)$

    $serialization_functions(bitset)$
$endif$

    $extensions : {$it$}; separator="\n"$

    vbs_user_DllExport std::bitset<$bitset.bitSize$> get_bitset() const;

    std::string to_idl_string(std::set<std::string>* processedTypes = nullptr, const bool is_top = true) const;

$if(ctx.HasMutable)$
$if(!ctx.PureStructure)$
    void serialize($ecdr_namespace_get(ctx=ctx)$Cdr& scdr) const;

    void deserialize($ecdr_namespace_get(ctx=ctx)$Cdr& scdr);
$endif$
$endif$

    vbs_user_DllExport std::bitset<$bitset.bitSize$> bitset() const;

    vbs_user_DllExport void bitset(
            const std::bitset<$bitset.bitSize$>&);

$if(ctx.Rpc)$
    void reset_all_member();
$endif$

$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
    friend vbs_user_DllExport std::ostream& operator<<(std::ostream& o, const $bitset.scopedname$& sample);

$endif$
$endif$

$if(!ctx.PureStructure)$
    void VBSVersionPrinter() {
        std::cout << "VBS IDL Gen Version 1.3.0-20240522-001" << std::endl;
    }

$if(!ctx.GenBoth)$
    void VBS$if(ctx.Rpc)$Rpc$else$Dds$endif$Printer() {
        std::cout << "This is $if(ctx.Rpc)$Rpc$else$Dds$endif$ code." << std::endl;
    }
$endif$
$endif$

$if(ctx.TestExample)$
    vbs_user_DllExport void updateTest(int index){
        static_cast<void>(index);
        for (int i = 0; i < $bitset.bitSize$; ++i) {
            m_bitset.set(i, (index & (1ULL << i)) != 0);
        }
    }
$endif$

private:

    std::bitset<$bitset.bitSize$> m_bitset;
};

$if(bitset.ScopednameList)$
$bitset.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$

$if(bitset.forwarded)$
$if(!ctx.NotUseVbsFramework)$
namespace vbs {
$if(!ctx.CJ)$
$if(!ctx.RmPrintHelper)$
void data_to_json_string(const $bitset.scopedname$& sample,
                std::ostringstream* o_ptr = nullptr, const bool is_need_delete = false, const bool include_braces = true);
$endif$
$endif$

}
$endif$
$endif$
>>

enum_type(ctx, parent, enum) ::= <<

$if(enum.ScopednameList)$
$enum.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

/*!
 * @brief This class represents the enumeration $enum.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
struct $enum.name$_def
{
    enum type {
        $enum.members:{$if(it.HasValue)$$it.name$ = $it.Value$$else$$it.name$$endif$}; separator=",\n"$
    };
    static type get_default(){ return $enum.InitialMember$;}
};

typedef ::vbs::safe_enum< $enum.name$_def > $enum.name$;

$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
    vbs_user_DllExport std::ostream& operator<<(std::ostream& o, const $enum.name$& sample);
$endif$
$endif$

    std::string to_idl_string(const $enum.name$& /* sample */, std::set<std::string>* processedTypes = nullptr, const bool is_top = true);

$if(enum.ScopednameList)$
$enum.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$

$if(enum.forwarded)$
$if(!ctx.NotUseVbsFramework)$
namespace vbs {
$if(!ctx.CJ)$
$if(!ctx.RmPrintHelper)$
void data_to_json_string(const $enum.scopedname$& sample,
                std::ostringstream* o_ptr = nullptr, const bool is_need_delete = false, const bool include_braces = true);
$endif$
$endif$

}
$endif$
$endif$
>>

bitmask_type(ctx, parent, bitmask) ::= <<

$if(bitmask.ScopednameList)$
$bitmask.ScopednameList : { namespace |
namespace $namespace$ \{
}; separator="\n"$
$endif$

/*!
 * @brief This class represents the bitmask $bitmask.name$ defined by the user in the IDL file.
 * @ingroup $ctx.trimfilename$
 */
enum class $bitmask.name$$bitmask.boundType$
{
    $bitmask.members:{$it.name$ = 0x01$bitmask.BoundTail$ << $it.position$}; separator=",\n"$
};

$if(ctx.CJ)$
$else$
$if(ctx.RmPrintHelper)$
$else$
    vbs_user_DllExport std::ostream& operator<<(std::ostream& o, const $bitmask.name$& sample);
$endif$
$endif$

    std::string to_idl_string(const $bitmask.name$& /* sample */, std::set<std::string>* processedTypes = nullptr, const bool is_top = true);
$if(bitmask.ScopednameList)$
$bitmask.ScopednameList : { namespace |
\}
}; separator="\n"$
$endif$

$if(bitmask.forwarded)$
$if(!ctx.NotUseVbsFramework)$
namespace vbs {
$if(!ctx.CJ)$
$if(!ctx.RmPrintHelper)$
void data_to_json_string(const $bitmask.scopedname$& sample,
                std::ostringstream* o_ptr = nullptr, const bool is_need_delete = false, const bool include_braces = true);
$endif$
$endif$

}
$endif$
$endif$
>>

/***** Utils *****/

public_struct_inheritances(parent) ::= <<$parent.scopedname$>>

public_bitset_inheritances(parent) ::= <<$parent.scopedname$>>

public_member_declaration(ctx, member, istop) ::= <<
$if(ctx.generateTypesC)$
$if(member.typecode.isStringType)$
$public_member_cstring_declaration(ctx=ctx, member=member)$
$else$
$public_member_primitive_declaration(ctx=ctx, member=member)$
$if(struct.UseBBMode)$
$if(struct.top)$
$public_member_primitive_declaration_seq_bb(ctx=ctx, member=member, istop=istop)$
$endif$
$endif$
$endif$
$else$
$public_member_primitive_declaration(ctx=ctx, member=member)$
$if(struct.UseBBMode)$
$if(struct.top)$
$public_member_primitive_declaration_seq_bb(ctx=ctx, member=member, istop=istop)$
$endif$
$endif$
$endif$
>>

public_member_primitive_declaration(ctx, member) ::= <<

/*!
 * @brief This function returns a const reference to member $member.name$
 * @param _$member.name$ New value to be copied in member $member.name$
 */
vbs_user_DllExport void $member.name$(
        const $member_type_declaration(ctx = ctx, member = member)$& _$member.name$);
/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
vbs_user_DllExport void $member.name$(
        $member_type_declaration(ctx = ctx, member = member)$&& _$member.name$);

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
vbs_user_DllExport $member_type_declaration(ctx = ctx, member = member)$& $member.name$();

$if(member.typecode.primitive)$
$if(ctx.RtiIdl)$
/*!
* @brief This function returns a reference to member $member.name$
* @return Const reference to member $member.name$
*/
vbs_user_DllExport const $member_type_declaration(ctx = ctx, member = member)$& $member.name$() const;
$else$
/*!
* @brief This function returns the value of member $member.name$
* @return Value of member $member.name$
*/
vbs_user_DllExport $member_type_declaration(ctx = ctx, member = member)$ $member.name$() const;
$endif$

$else$
/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 */
vbs_user_DllExport const $member_type_declaration(ctx = ctx, member = member)$& $member.name$() const;
$endif$
>>

public_member_primitive_declaration_seq_bb(ctx, member, istop) ::= <<

$if (member.typecode.UseBBMode)$
$if (member.typecode.isSequenceType)$

/*!
 * @brief This function returns a pointer to member $member.name$
 * @return pointer to member $member.name$
 */
vbs_user_DllExport $member.typecode.ContentTypeCode.cppTypename$* $member.name$_ptr();

/*!
 * @brief This function set the size of member $member.name$
 * @param _$member.name$_size the size of member $member.name$
 */
vbs_user_DllExport void $member.name$_size(const uint32_t _$member.name$_size);

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 */
vbs_user_DllExport uint32_t $member.name$_size();
$endif$
$endif$
>>

public_member_cstring_declaration(ctx, member) ::= <<
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
vbs_user_DllExport void $member.name$(
        const $member_type_declaration(ctx = ctx, member = member)$ _$member.name$);

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
vbs_user_DllExport const $member_type_declaration(ctx = ctx, member = member)$ $member.name$() const;
>>

public_bitfield_declaration(member) ::= <<
$if(member.name)$
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
vbs_user_DllExport void $member.name$(
        $member.spec.cppTypename$ _$member.name$);

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 */
vbs_user_DllExport $member.spec.cppTypename$ $member.name$() const;
$endif$
>>

private_member_declaration(ctx, member, istop) ::= <<
$private_declaration(ctx=ctx, typecode=member.typecode, name=member.name, istop=istop, member = member)$
>>

public_unionmember_declaration(ctx, member, istop) ::= <<
$if(ctx.GenerateTypesC)$
$if(member.typecode.isStringType)$
$public_unionmember_cstring_declaration(ctx=ctx, member=member)$
$else$
$if(ctx.ZeroCopy)$
$public_unionmember_primitive_declaration_seq_bb(ctx=ctx, member=member, istop=istop)$
$else$
$public_unionmember_primitive_declaration(ctx=ctx, member=member)$
$endif$
$endif$
$else$
$if(ctx.ZeroCopy)$
$public_unionmember_primitive_declaration_seq_bb(ctx=ctx, member=member, istop=istop)$
$else$
$public_unionmember_primitive_declaration(ctx=ctx, member=member)$
$endif$
$endif$
>>

public_unionmember_primitive_declaration(ctx, member) ::= <<
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ Const reference to be copied in member $member.name$
 */
vbs_user_DllExport void $member.name$(
        const $member_type_declaration(ctx = ctx, member = member)$& _$member.name$);

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
vbs_user_DllExport void $member.name$(
        $member_type_declaration(ctx = ctx, member = member)$&& _$member.name$);

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport $member_type_declaration(ctx = ctx, member = member)$& $member.name$();
$if(member.typecode.primitive)$

$if(ctx.RtiIdl)$
/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport const $member_type_declaration(ctx = ctx, member = member)$& $member.name$() const;
$else$
/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport $member_type_declaration(ctx = ctx, member = member)$ $member.name$() const;
$endif$

$else$
/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport const $member_type_declaration(ctx = ctx, member = member)$& $member.name$() const;
$endif$
>>

public_unionmember_primitive_declaration_seq_bb(ctx, member, istop) ::= <<
/*!
 * @brief This function copies the value in member $member.name$
 * @param _$member.name$ Const reference to be copied in member $member.name$
 */
vbs_user_DllExport void $member.name$(
        const $member_type_declaration(ctx = ctx, member = member)$& _$member.name$);

/*!
 * @brief This function moves the value in member $member.name$
 * @param _$member.name$ New value to be moved in member $member.name$
 */
vbs_user_DllExport void $member.name$(
        $member_type_declaration(ctx = ctx, member = member)$&& _$member.name$);

/*!
 * @brief This function returns a reference to member $member.name$
 * @return Reference to member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport $member_type_declaration(ctx = ctx, member = member)$& $member.name$();
$if(member.typecode.primitive)$

$if(ctx.RtiIdl)$
/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport const $member_type_declaration(ctx = ctx, member = member)$& $member.name$() const;
$else$
/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport $member_type_declaration(ctx = ctx, member = member)$& $member.name$() const;
$endif$

$else$
/*!
 * @brief This function returns a constant reference to member $member.name$
 * @return Constant reference to member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport const $member_type_declaration(ctx = ctx, member = member)$& $member.name$() const;
$endif$
>>

public_unionmember_cstring_declaration(ctx, member) ::= <<
/*!
 * @brief This function sets a value in member $member.name$
 * @param _$member.name$ New value for member $member.name$
 */
vbs_user_DllExport void $member.name$(
        const $member.typecode.cppTypename$ _$member.name$);

/*!
 * @brief This function returns the value of member $member.name$
 * @return Value of member $member.name$
 * @exception $ecdr_namespace_get(ctx=ctx)$BadParamException This exception is thrown if the requested union member is not the current selection.
 */
vbs_user_DllExport const $member.typecode.cppTypename$ $member.name$() const;
>>

private_declaration(ctx, typecode, name, istop, member) ::= <<
$if(ctx.ZeroCopy)$
$if(typecode.UseBBMode)$
$if(istop)$
mutable void* m_$name$;
$else$
$member_type_declaration(ctx = ctx, member = member)$$if(member.NeedsPointer)$*$endif$ m_$name$$if(member.NeedsPointer)$ = nullptr$endif$;
$endif$
$else$
$member_type_declaration(ctx = ctx, member = member)$$if(member.NeedsPointer)$*$endif$ m_$name$$if(member.NeedsPointer)$ = nullptr$endif$;
$endif$
$else$
$member_type_declaration(ctx = ctx, member = member)$$if(member.NeedsPointer)$*$endif$ m_$name$$if(member.NeedsPointer)$ = nullptr$endif$;
$endif$
>>

/*! TODO Quitado de VBSBuffers porque no encaja con las excepciones de erpc.
 * @brief This function calculates the space needed to serialize a type $type.scopedname$.
 *        For all types with a variable size (strings, sequences) and without a maximum limit, this function uses
 *        255 as maximum limit.
 *
 inline
 $big_align(ctx=ctx)$ getMaxSerializedSize() { return $type.maxSerializedSize$;}

 *!
 * @brief This function calculates the space needed to serialize a type $type.scopedname$ without alignment.
 *        For all types with a variable size (strings, sequences) and without a maximum limit, this function uses
 *        255 as maximum limit.
 *
 inline
 $big_align(ctx=ctx)$ getMaxSerializedSizeWithoutAlign(){ return $type.maxSerializedSizeWithoutAlignment$;}
 */

size_functions(type) ::= <<
$if(ctx.HasMutable)$
$else$
$if(ctx.anyCdr)$
/*!
 * @brief This function returns the maximum serialized size of an object
 * depending on the buffer alignment.
 * @param current_alignment Buffer alignment.
 * @return Maximum serialized size.
 */
vbs_user_DllExport static $big_align(ctx=ctx)$ getMaxCdrSerializedSize(
        $big_align(ctx=ctx)$ current_alignment = 0);

/*!
 * @brief This function returns the serialized size of a data depending on the buffer alignment.
 * @param data Data which is calculated its serialized size.
 * @param current_alignment Buffer alignment.
 * @return Serialized size.
 */
vbs_user_DllExport static $big_align(ctx=ctx)$ getCdrSerializedSize(
        const $type.scopedname$& data,
        $big_align(ctx=ctx)$ current_alignment = 0);

/*!
 * @brief This function returns the size of an object.
 * @param current_alignment Buffer alignment.
 * @return Maximum serialized size.
 */
vbs_user_DllExport static $big_align(ctx=ctx)$ getObjectDataSize();

$endif$
$endif$
>>

serialization_functions(type) ::= <<
$if(ctx.HasMutable)$
$else$
$if(ctx.cdr)$
/*!
 * @brief This function serializes an object using CDR serialization.
 * @param cdr CDR serialization object.
 */
vbs_user_DllExport void serialize(
        $ecdr_namespace_get(ctx=ctx)$Cdr& cdr) const;

/*!
 * @brief This function deserializes an object using CDR serialization.
 * @param cdr CDR serialization object.
 */
vbs_user_DllExport void deserialize(
        $ecdr_namespace_get(ctx=ctx)$Cdr& cdr);

$endif$

$if(ctx.vbscdr)$
/*!
 * @brief This function serializes an object using ECDR serialization.
 * @param cdr ECDR serialization object.
 */
vbs_user_DllExport void serialize(
        $ecdr_namespace_get(ctx=ctx)$ECdr& cdr) const;

/*!
 * @brief This function deserializes an object using ECDR serialization.
 * @param cdr ECDR serialization object.
 */
vbs_user_DllExport void deserialize(
        $ecdr_namespace_get(ctx=ctx)$ECdr& cdr);

$endif$
$endif$
>>

sequences_definition(typecode) ::= <<
$if(typecode.contentTypeCode.isStructType)$
$typecode.contentTypeCode.namespaces : { namespace $it$ \{ }; separator="\n"$
class $typecode.contentTypeCode.name$;
$typecode.contentTypeCode.namespaces : { \} }; separator="\n"$
$endif$
$if(typecode.contentTypeCode.isUnionType)$
$typecode.contentTypeCode.namespaces : { namespace $it$ \{ }; separator="\n"$
class $typecode.contentTypeCode.name$;
$typecode.contentTypeCode.namespaces : { \} }; separator="\n"$
$endif$

$sequences_definition_impl(typecode=typecode, typename=typecode.cppTypename)$
>>

sequences_definition_impl(typecode, typename) ::= <<

class vbs_user_DllExport $typename$
{
public:
    $typename$();

    $typename$(
            uint32_t maximum);

    $typename$(
            uint32_t length,
            $typecode.contentTypeCode.cppTypename$* data,
            bool release = false);

    $typename$(
            const $typename$& $typename$_);

    $typename$& operator =(
            const $typename$& $typename$_);

    ~$typename$();

    $typecode.contentTypeCode.cppTypename$$if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$$else$&$endif$$else$&$endif$ operator[](
            uint32_t index);

    const $typecode.contentTypeCode.cppTypename$$if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$$else$&$endif$$else$&$endif$ operator[](
            uint32_t index) const;

    void size(
            uint32_t size);

    uint32_t size() const;

    void length(
            uint32_t size);

    uint32_t length() const;

    uint32_t maximum() const;

    void value(
            $typecode.contentTypeCode.cppTypename$* value);

    $typecode.contentTypeCode.cppTypename$* value(
            bool orphan = false);

    const $typecode.contentTypeCode.cppTypename$$if(ctx.generateTypesC)$$if(typecode.contentTypeCode.isStringType)$ const$else$$endif$$else$$endif$* value() const;

    void release(
            bool release);

    bool release() const;

    bool& release();

$if(!ctx.PureStructure)$
$if(ctx.HasMutable)$
$else$
$if(ctx.anyCdr)$
    static $big_align(ctx=ctx)$ getMaxCdrSerializedSize(
            $big_align(ctx=ctx)$ current_alignment = 0);

    static $big_align(ctx=ctx)$ getCdrSerializedSize(
            const $typename$& data,
            $big_align(ctx=ctx)$ current_alignment = 0);

$endif$

    void serialize(
            $ecdr_namespace_get(ctx=ctx)$Cdr& cdr) const;

    void deserialize(
            $ecdr_namespace_get(ctx=ctx)$Cdr& cdr);
$endif$
$endif$

private:

    uint32_t maximum_ = $typecode.maxsize$;

    mutable uint32_t length_ = 0;

    mutable $typecode.contentTypeCode.cppTypename$* value_ = nullptr;

    bool release_ = true;

    void free_memory();
};
>>

/*UTILS*/
ecdr_namespace_get(ctx) ::= <<$if(ctx.NotUseVbsFramework)$vbsutil::ecdr::$else$vbs::$endif$>>

evbs_namespace_get(ctx) ::= <<$if(ctx.NotUseVbsFramework)$vbs::$else$vbs::$endif$>>

left_brackets() ::= <<{>>

right_brackets() ::= <<}>>

big_align(ctx) ::= <<$if(ctx.BigAlignment)$int64_t$else$size_t$endif$>>

ertps_namespace_get(ctx) ::= <<$if(ctx.NotUseVbsFramework)$$if(ctx.HasMutable)$vbsutil::ecdr::$else$$if(ctx.GenBoth)$evbs::ertps::$else$$if(ctx.Rpc)$vbsutil::ecdr::$else$evbs::ertps::$endif$$endif$$endif$$else$vbs::$endif$>>
