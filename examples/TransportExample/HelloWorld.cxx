// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ------------------------------------------------------------------
// Modification history:
// feature: Modify test cases
// ------------------------------------------------------------------

/*!
 * @file HelloWorld.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "HelloWorld.h"

#include <utility>

#ifndef _FIRST_DEFINE_DJS
#define _FIRST_DEFINE_DJS

template <typename T>
void printHelloWorld(std::ostream& os, const T& t);
template <>
void printHelloWorld(std::ostream& os, const uint8_t& value);

template <std::size_t N>
void printHelloWorld(std::ostream& os, const vbs::fixed_string<N>& str);

template <typename T>
void vbs_print_osHelloWorld(std::ostream& os, const T& t, const bool is_json = false);

template <>
inline void vbs_print_osHelloWorld(std::ostream& os, const std::wstring& str, const bool is_json);

template <std::size_t N>
void vbs_print_osHelloWorld(std::ostream& os, const vbs::fixed_string<N>& str, const bool is_json = false);

template <typename K>
void print_json_key(std::ostream& os, const K& key);

template <typename T, std::size_t N>
std::ostream& vbs_print_osHelloWorld(std::ostream& os, const std::array<T, N>& arr, bool is_json = false);

template <typename T, std::size_t N>
void printHelloWorld(std::ostream& os, const std::array<T, N>& arr);

template <typename T>
std::ostream& vbs_print_osHelloWorld(std::ostream& os, const std::vector<T>& vec, bool is_json = false);

template <typename T>
void printHelloWorld(std::ostream& os, const std::vector<T>& vec);

template <typename K, typename V>
std::ostream& vbs_print_osHelloWorld(std::ostream& os, const std::map<K, V>& m, const bool is_json = false);

template <typename K, typename V>
void printHelloWorld(std::ostream& os, const std::map<K, V>& m);

namespace vbs {

inline void data_to_json_string(const bool& sample, std::ostringstream* o_ptr = nullptr,
                                const bool is_need_delete = false);
inline void data_to_json_string(const char& sample, std::ostringstream* o_ptr = nullptr,
                                const bool is_need_delete = false);
inline void data_to_json_string(const wchar_t& sample, std::ostringstream* o_ptr = nullptr,
                                const bool is_need_delete = false);
inline void data_to_json_string(const std::string& sample, std::ostringstream* o_ptr = nullptr,
                                const bool is_need_delete = false);

template <std::size_t N>
inline void data_to_json_string(const vbs::fixed_string<N>& str, std::ostringstream* o_ptr = nullptr,
                                const bool is_json = false);

inline void data_to_json_string(const int8_t& sample, std::ostringstream* o_ptr = nullptr, const bool is_json = false);

inline void data_to_json_string(const uint8_t& sample, std::ostringstream* o_ptr = nullptr, const bool is_json = false);

inline void data_to_json_string(const float& sample, std::ostringstream* o_ptr = nullptr,
                                const bool is_need_delete = false);

inline void data_to_json_string(const double& sample, std::ostringstream* o_ptr = nullptr,
                                const bool is_need_delete = false);

template <typename T>
void data_to_json_string(const T& sample, std::ostringstream* o_ptr = nullptr, const bool is_need_delete = true,
                         const bool include_braces = true);

inline void data_to_json_string(const bool& sample, std::ostringstream* o_ptr, const bool is_need_delete) {
    (void)is_need_delete;
    *o_ptr << (sample ? "true" : "false");
    return;
}

inline void data_to_json_string(const char& sample, std::ostringstream* o_ptr, const bool is_need_delete) {
    (void)is_need_delete;
    unsigned char uvalue = static_cast<unsigned char>(sample);
    *o_ptr << "\"\\u" << std::setw(4) << std::setfill('0') << std::hex << static_cast<int>(uvalue) << "\"";
    return;
}

inline void data_to_json_string(const wchar_t& sample, std::ostringstream* o_ptr, const bool is_need_delete) {
    (void)is_need_delete;
    unsigned char uvalue = static_cast<unsigned char>(sample);
    *o_ptr << "\"\\u" << std::setw(4) << std::setfill('0') << std::hex << static_cast<int>(uvalue) << "\"";
    return;
}

inline void data_to_json_string(const std::string& sample, std::ostringstream* o_ptr, const bool is_need_delete) {
    (void)is_need_delete;
    *o_ptr << "\"" << sample << "\"";
    return;
}

template <std::size_t N>
inline void data_to_json_string(const vbs::fixed_string<N>& str, std::ostringstream* o_ptr, const bool is_json) {
    (void)is_json;
    *o_ptr << "\"" << str.to_string() << "\"";
}

inline void data_to_json_string(const int8_t& sample, std::ostringstream* o_ptr, const bool is_json) {
    (void)is_json;
    *o_ptr << static_cast<int>(sample);
}

inline void data_to_json_string(const uint8_t& sample, std::ostringstream* o_ptr, const bool is_json) {
    (void)is_json;
    *o_ptr << static_cast<int>(sample);
}

inline void data_to_json_string(const float& sample, std::ostringstream* o_ptr, const bool is_need_delete) {
    (void)is_need_delete;
    *o_ptr << std::setprecision(16);

    if (std::isnan(sample)) {
        *o_ptr << "nan";
    } else if (std::isinf(sample)) {
        *o_ptr << "inf";
    } else {
        float abs_sample = std::abs(sample);
        if (abs_sample >= 1e16f || (sample != 0.0f && abs_sample < 1e-16f)) {
            *o_ptr << std::scientific << sample;
        } else {
            *o_ptr << sample;
        }
    }
}

inline void data_to_json_string(const double& sample, std::ostringstream* o_ptr, const bool is_need_delete) {
    (void)is_need_delete;
    *o_ptr << std::setprecision(16);

    if (std::isnan(sample)) {
        *o_ptr << "nan";
    } else if (std::isinf(sample)) {
        *o_ptr << "inf";
    } else {
        double abs_sample = std::abs(sample);
        if (abs_sample >= 1e16 || (sample != 0.0 && abs_sample < 1e-16)) {
            *o_ptr << std::scientific << sample;
        } else {
            *o_ptr << sample;
        }
    }
}

template <typename T>
void data_to_json_string(const T& sample, std::ostringstream* o_ptr, const bool is_need_delete,
                         const bool include_braces) {
    (void)is_need_delete;
    (void)include_braces;
    *o_ptr << sample;
    return;
}

}  // namespace vbs
#endif

HelloWorld::HelloWorld() {

    // m_index uint32_t
    m_index = 0;
    // m_message std::string
    m_message = "";
}

HelloWorld::~HelloWorld() {}

HelloWorld::HelloWorld(const HelloWorld& x) {
    (m_index) = x.m_index;
    (m_message) = x.m_message;
}
HelloWorld::HelloWorld(HelloWorld&& x) {
    (m_index) = x.m_index;
    (m_message) = std::move(x.m_message);
}

HelloWorld::HelloWorld(const uint32_t& index, const std::string& message) {
    (m_index) = index;
    (m_message) = message;
}
HelloWorld& HelloWorld::operator=(const HelloWorld& x) {

    if (this != &x) {
        (m_index) = x.m_index;
        (m_message) = x.m_message;
    }
    return *this;
}
HelloWorld& HelloWorld::operator=(HelloWorld&& x) {

    (m_index) = x.m_index;
    (m_message) = std::move(x.m_message);

    return *this;
}

bool HelloWorld::operator==(const HelloWorld& x) const {
    return (this->index() == x.index() && this->message() == x.message());
}

bool HelloWorld::operator!=(const HelloWorld& x) const {
    return !(*this == x);
}

void HelloWorld::swap(HelloWorld& other_) {
    std::swap(m_index, other_.m_index);
    std::swap(m_message, other_.m_message);
}

size_t HelloWorld::getMaxCdrSerializedSize(size_t current_alignment) {
    static_cast<void>(current_alignment);
    return HelloWorld_max_cdr_typesize;
}

size_t HelloWorld::getCdrSerializedSize(const HelloWorld& data, size_t current_alignment) {
    (void)data;
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + vbs::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + vbs::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;

    return current_alignment - initial_alignment;
}

size_t HelloWorld::getObjectDataSize() {
    return getMaxCdrSerializedSize();
}

void HelloWorld::serialize(vbs::Cdr& scdr) const {

    scdr << m_index;
    scdr << m_message.c_str();
}

void HelloWorld::deserialize(vbs::Cdr& dcdr) {
    dcdr >> m_index;
    dcdr >> m_message;
}

/*!
 * @brief This function sets a value in member index
 * @param _index const reference for member index
 */
void HelloWorld::index(const uint32_t& _index) {
    (m_index) = _index;
}

/*!
 * @brief This function moves the value in member index
 * @param _index New value to be moved in member index
 */
void HelloWorld::index(uint32_t&& _index) {
    (m_index) = _index;
}

/*!
 * @brief This function returns a reference to member index
 * @return Reference to member index
 */
uint32_t& HelloWorld::index() {
    return (m_index);
}

/*!
 * @brief This function returns the value of member index
 * @return Value of member index
 */
uint32_t HelloWorld::index() const {
    return (m_index);
}
/*!
 * @brief This function sets a value in member message
 * @param _message const reference for member message
 */
void HelloWorld::message(const std::string& _message) {
    (m_message) = _message;
}

/*!
 * @brief This function moves the value in member message
 * @param _message New value to be moved in member message
 */
void HelloWorld::message(std::string&& _message) {
    (m_message) = _message;
}

/*!
 * @brief This function returns a reference to member message
 * @return Reference to member message
 */
std::string& HelloWorld::message() {
    return (m_message);
}

/*!
 * @brief This function returns a constant reference to member message
 * @return Constant reference to member message
 */
const std::string& HelloWorld::message() const {
    return (m_message);
}

size_t HelloWorld::getKeyMaxCdrSerializedSize(size_t current_alignment) {
    size_t current_align = current_alignment;

    return current_align;
}
bool HelloWorld::isKeyDefined() {
    return false;
}

void HelloWorld::serializeKey(vbs::Cdr& scdr) const {
    (void)scdr;
}

template <typename T>
void printHelloWorld(std::ostream& os, const T& t) {
    os << t;
}

template <typename T>
void vbs_print_osHelloWorld(std::ostream& os, const T& t, const bool is_json) {
    if (is_json) {
        std::ostringstream oss;
        vbs::data_to_json_string(t, &oss, false);
        os << oss.str();
    } else {
        printHelloWorld(os, t);
    }
}

template <>
void printHelloWorld(std::ostream& os, const uint8_t& value) {
    os << static_cast<int>(value);
}

std::ostream& operator<<(std::ostream& o, const HelloWorld& sample) {
    o << "{\n";
    o << "index: ";
    printHelloWorld(o, sample.index());
    o << "\n";
    o << "message: " << sample.message() << "\n";
    o << "}\n";
    return o;
}

std::string HelloWorld::get_type_name() {
    return "HelloWorld";
}

std::string HelloWorld::to_idl_string(std::set<std::string>* processedTypesPtr, const bool is_top) const {
    if (!processedTypesPtr && is_top) {
        processedTypesPtr = new std::set<std::string>();
    }
    if (processedTypesPtr && (processedTypesPtr->find("HelloWorld") == processedTypesPtr->end())) {
        processedTypesPtr->insert("HelloWorld");
    } else {
        if (!is_top) {
            return "";
        }
    }
    std::ostringstream oss;

    oss << "struct HelloWorld {\n"

           "    unsigned long index;\n"

           "    string message;\n"
           "};\n";

    if (is_top) {
        delete processedTypesPtr;
    }
    return oss.str();
}

namespace vbs {
std::string data_to_json_string(const HelloWorld& sample, std::ostringstream* o_ptr, const bool is_need_delete,
                                const bool include_braces) {
    if (o_ptr == nullptr && is_need_delete) {
        o_ptr = new std::ostringstream();
    }
    std::ostringstream& o = *o_ptr;
    if (include_braces)
        o << "{"
          << "\n";

    o << "\"index\": ";
    ::vbs_print_osHelloWorld(o, sample.index(), true);
    o << "\n";

    o << ",";
    o << "\"message\": ";
    vbs::data_to_json_string(sample.message(), o_ptr, false);

    o << "\n";
    if (include_braces)
        o << "}\n";
    if (!is_need_delete)
        return "";
    std::string tmp_res_str = o.str();

    if (o_ptr && is_need_delete) {
        delete o_ptr;
        o_ptr = nullptr;
    }
    return tmp_res_str;
}
}  // namespace vbs
